diff --git a/Makefile b/Makefile
index 9f058ca2..70064d1b 100755
--- a/Makefile
+++ b/Makefile
@@ -160,7 +160,7 @@ obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
 	$(HIDE)$(CC_CMD)
 
 lib/libc.so: $(LOBJS) $(LDSO_OBJS)
-	$(HIDE)$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
+	$(HIDE)$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -L lib/ -ldl -lpthread -nostdlib -shared \
 	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
 
 lib/libc.a: $(AOBJS)
diff --git a/configure b/configure
index a2728969..b45d8e88 100755
--- a/configure
+++ b/configure
@@ -467,8 +467,8 @@ fi
 # unstrippable. These options force them back to debug sections (and
 # cause them not to get generated at all if debugging is off).
 #
-tryflag CFLAGS_AUTO -fno-unwind-tables
-tryflag CFLAGS_AUTO -fno-asynchronous-unwind-tables
+# tryflag CFLAGS_AUTO -fno-unwind-tables
+# tryflag CFLAGS_AUTO -fno-asynchronous-unwind-tables
 
 #
 # Attempt to put each function and each data object in its own
diff --git a/include/debug.h b/include/debug.h
new file mode 100644
index 00000000..674ccaa9
--- /dev/null
+++ b/include/debug.h
@@ -0,0 +1,88 @@
+#ifndef _DEBUG_H
+#define _DEBUG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Initialization of the memory debug function, including the output method of memory debug information
+ * and signal registration. You can use command line parameters, "--mwatch" or "--mrecord <full path>", to
+ * call mem_check_init(char *) when executing your program.
+ *
+ * @param f_path   The full path of the file to be created where the memory debug information will be written.
+ * If the param is NULL or the file creation fails, the memory debug information will be output via serial
+ * port.
+ *
+ * @return void.
+ */
+void mem_check_init(char *f_path);
+
+/**
+ * @brief View thread-level heap memory usage information, signal registration index is 35, you can use "kill -35 pid"
+ * to call watch_mem() when your program is running. The output way of memory debug information is determined by how
+ * the mem_check_init(char *) interface is called.
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void watch_mem(void);
+
+/**
+ * @brief Check whether the heap memory leak is exist or not, signal registration index is 36, you can use "kill -36
+ * pid" to call check_leak() when your program is running. The output way of memory debug information is determined by
+ * how the mem_check_init(char *) interface is called.
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void check_leak(void);
+
+/**
+ * @brief Check whether the heap memory is integrited or not, signal registration index is 37, you can use "kill -37
+ * pid" to call check_heap_integrity() when your program is running. The output way of memory debug information is
+ * determined by how the mem_check_init(char *) interface is called.
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void check_heap_integrity(void);
+
+/**
+ * @brief Store the address of the call stack information, the max number is param size.
+ *
+ * @param buffer   The array to store address of the call stack information.
+ * @param size     The size of buffer.
+ *
+ * @return The exact number of the address.
+ */
+int backtrace(void **buffer, int size);
+
+/**
+ * @brief Find the symbol information corresponding to the address stored in the buffer for dynamic linking.
+ *
+ * @param buffer   The array stored address of the exact number.
+ * @param size     The exact number of the address stored in the buffer.
+ *
+ * @return The pointer to the memory allocated from heap holds the symbol information corresponding to the address
+ * stored in the buffer. You should free the memory the pointer points to after calling backtrace_symbols().
+ */
+char **backtrace_symbols(void *const *buffer, int size);
+
+/**
+ * @brief Print the call stack information of the function calling print_trace().
+ *
+ * @param void.
+ *
+ * @return void.
+ */
+void print_trace(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ldso/dynlink.c b/ldso/dynlink.c
index 40e05220..e311c674 100644
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -1756,7 +1756,7 @@ void __dls3(size_t *sp, size_t *auxv)
 		}
 		if (DL_FDPIC) app.loadmap = app_loadmap;
 		if (app.tls.size) app.tls.image = laddr(&app, tls_image);
-		if (interp_off) ldso.name = laddr(&app, interp_off);
+		if (interp_off) ldso.name = "/lib/libc.so";
 #if 0
 		if ((aux[0] & (1UL<<AT_EXECFN))
 		    && strncmp((char *)aux[AT_EXECFN], "/proc/", 6))
diff --git a/src/env/__libc_start_main.c b/src/env/__libc_start_main.c
index 9f0fec0e..2a380d82 100644
--- a/src/env/__libc_start_main.c
+++ b/src/env/__libc_start_main.c
@@ -11,6 +11,7 @@ static void dummy(void) {}
 weak_alias(dummy, _init);
 
 extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);
+extern void parse_argv(int, char **);
 
 static void dummy1(void *p) {}
 weak_alias(dummy1, __init_ssp);
@@ -91,6 +92,7 @@ static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, ch
 	__libc_start_init();
 	__sig_init();
 
+	parse_argv(argc, argv);
 	/* Pass control to the application */
 	exit(main(argc, argv, envp));
 	return 0;
diff --git a/src/exit/exit.c b/src/exit/exit.c
index a6869b37..5d2d00a3 100644
--- a/src/exit/exit.c
+++ b/src/exit/exit.c
@@ -1,7 +1,13 @@
 #include <stdlib.h>
 #include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
 #include "libc.h"
 
+extern bool g_enable_check;
+extern void mem_check_deinit(void);
+extern void clean_recycle_list(bool clean_all);
+
 static void dummy()
 {
 }
@@ -26,6 +32,12 @@ weak_alias(libc_exit_fini, __libc_exit_fini);
 
 _Noreturn void exit(int code)
 {
+	if (g_enable_check) {
+		check_leak();
+		check_heap_integrity();
+		mem_check_deinit();
+		clean_recycle_list(true);
+	}
 	__funcs_on_exit();
 	__libc_exit_fini();
 	__stdio_exit();
diff --git a/src/internal/malloc_impl.h b/src/internal/malloc_impl.h
index 59785a7f..6107f0b6 100644
--- a/src/internal/malloc_impl.h
+++ b/src/internal/malloc_impl.h
@@ -2,6 +2,20 @@
 #define MALLOC_IMPL_H
 
 #include <sys/mman.h>
+#include <stdbool.h>
+
+#define BACKTRACE_DEPTH_MAX      5          /* The max depth of backtrace */
+#define BACKTRACE_START_OFFSET   0          /* The start offset of backtrace */
+#define SECONDARY_CALL_OFFSET    2          /* The backtrace offset for secondary call backtrace() */
+#define BACKTRACE_OFFSET         (BACKTRACE_START_OFFSET + SECONDARY_CALL_OFFSET)
+#define PREFIX_PLACE_HOLDER      10         /* Reserve positions for file name prefix "pid()_" */
+#define PTHREAD_NUM_MAX          128        /* Same as number of task of kernel */
+#define NODE_MAGIC               0xFCFCFCFC /* Magic number for node of chunk */
+#define FREE_MAGIC               0xFE       /* Magic number for filling freed heap memory not recycled to heap pool */
+#define RECYCLE_MAX              128        /* The queue size for free() to recycle */
+#define RECYCLE_SIZE_MAX         0x300000   /* The max sum size of freed chunk for recycle list */
+#define ITEM_BUFFER_SIZE         256        /* The buffer max size for one item of memory debug info */
+#define CHECK_POINT_TRACE_MAX    2          /* The trace max for check point */
 
 hidden void *__expand_heap(size_t *);
 
@@ -10,21 +24,52 @@ hidden void __malloc_donate(char *, char *);
 hidden void *__memalign(size_t, size_t);
 
 struct chunk {
+	unsigned int checksum;
 	size_t psize, csize;
 	struct chunk *next, *prev;
 };
 
 struct bin {
+	unsigned int checksum;
 	volatile int lock[2];
 	struct chunk *head;
 	struct chunk *tail;
 };
 
-#define SIZE_ALIGN (4*sizeof(size_t))
+struct heap_block {
+	struct heap_block *next;
+	struct heap_block *prev;
+};
+
+struct list {
+	struct list *prev;
+	struct list *next;
+};
+
+struct node {
+	short tid, pid;
+	void *ptr;
+	size_t size;
+	void *lr[BACKTRACE_DEPTH_MAX];
+	struct list list;
+};
+
+struct stat_bin {
+	volatile int lock[2];
+	struct list head;
+	size_t t_total_size;
+};
+
+#define ROUNDUP(a, b) (((a) + ((b) - 1)) & ~((b) - 1))
+#define SIZE_ALIGN ROUNDUP(sizeof(struct chunk), 0x10)
 #define SIZE_MASK (-SIZE_ALIGN)
-#define OVERHEAD (2*sizeof(size_t))
-#define MMAP_THRESHOLD (0x1c00*SIZE_ALIGN)
-#define DONTCARE 16
+#define OVERHEAD (sizeof(struct chunk))
+#define BLOCK_HEAD (sizeof(struct heap_block) + OVERHEAD)
+#define CHUNK_BLOCK_OFFSET (sizeof(struct heap_block))
+#define CHUNK_TO_BLOCK(c) (struct heap_block *)((char *)(c) - CHUNK_BLOCK_OFFSET)
+#define BLOCK_TO_CHUNK(p) (struct chunk *)((char *)(p) + CHUNK_BLOCK_OFFSET)
+#define MMAP_THRESHOLD (0x1c00*(4*sizeof(size_t)))
+#define DONTCARE SIZE_ALIGN
 #define RECLAIM 163840
 
 #define CHUNK_SIZE(c) ((c)->csize & -2)
@@ -33,7 +78,7 @@ struct bin {
 #define NEXT_CHUNK(c) ((struct chunk *)((char *)(c) + CHUNK_SIZE(c)))
 #define MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)
 #define CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)
-#define BIN_TO_CHUNK(i) (MEM_TO_CHUNK(&mal.bins[i].head))
+#define BIN_TO_CHUNK(i) (&mal.bins[i].checksum)
 
 #define C_INUSE  ((size_t)1)
 
@@ -43,4 +88,18 @@ hidden void __bin_chunk(struct chunk *);
 
 hidden extern int __malloc_replaced;
 
+hidden extern bool g_enable_check;
+hidden extern int g_recycle_num;
+hidden extern size_t g_recycle_size;
+hidden extern int g_mem_lock[];
+hidden extern void insert_node(void *ptr, size_t size);
+hidden extern int delete_node(void *ptr);
+hidden extern void insert_block_list(struct chunk *ptr);
+hidden extern void insert_free_tail(struct chunk *self);
+hidden extern struct chunk *get_free_head(void);
+hidden extern void get_free_trace(void *ptr);
+hidden extern void clean_recycle_list(bool clean_all);
+hidden extern void check_chunk_integrity(struct chunk *cur);
+hidden extern void calculate_checksum(struct chunk *cur, struct chunk *next);
+
 #endif
diff --git a/src/malloc/backtrace.c b/src/malloc/backtrace.c
new file mode 100644
index 00000000..859bbee7
--- /dev/null
+++ b/src/malloc/backtrace.c
@@ -0,0 +1,141 @@
+#define _GNU_SOURCE
+#include <stdint.h>
+#include <malloc.h>
+#include <dlfcn.h>
+#include <string.h>
+#include <stdio.h>
+#include <debug.h>
+#include <unwind.h>
+
+#define TRACE_MAX_DEPTH 16
+#define STRING_MAX_LEN  256
+#define TRACE_IGNORE    1
+
+struct unwind_state_t {
+	_Unwind_Word **cur;
+	_Unwind_Word **end;
+};
+
+static _Unwind_Reason_Code unwind_callback(struct _Unwind_Context *context, void *arg)
+{
+	struct unwind_state_t *state = (struct unwind_state_t *)arg;
+	_Unwind_Word pc = _Unwind_GetIP(context);
+	if (pc != 0) {
+		if (state->cur != state->end) {
+			*state->cur = (_Unwind_Word *)pc;
+		} else {
+			return _URC_END_OF_STACK;
+		}
+	}
+	++state->cur;
+
+	return _URC_NO_REASON;
+}
+
+int backtrace(void **buffer, int size)
+{
+	struct unwind_state_t state;
+
+	if ((buffer == NULL) || (size <= 0)) {
+		return 0;
+	}
+
+	state.cur = (_Unwind_Word **)buffer;
+	state.end = (_Unwind_Word **)(buffer + size);
+	_Unwind_Backtrace(&unwind_callback, &state);
+
+	return (void **)state.cur - buffer;
+}
+
+char **backtrace_symbols(void *const *buffer, int size)
+{
+	int i;
+	char **str_location = NULL;
+	char *str_buffer = NULL;
+	char *str_base = NULL;
+	char **string = NULL;
+	Dl_info info = { 0 };
+	size_t total_size = 0;
+
+	if ((buffer == NULL) || (size <= 0)) {
+		return NULL;
+	}
+	str_location = (char **)malloc(size * sizeof(char *));
+	if (str_location == NULL) {
+		return NULL;
+	}
+	memset(str_location, 0, size * sizeof(char *));
+	for (i = 0; i < size; ++i) {
+		dladdr((void *)buffer[i], &info);
+		if ((info.dli_fname == NULL) || (info.dli_fname[0] == '\0')) {
+			break;
+		}
+		str_buffer = (char *)malloc(STRING_MAX_LEN * sizeof(char));
+		if (str_buffer == NULL) {
+			goto err;
+		}
+
+		snprintf(str_buffer, STRING_MAX_LEN, "    #%02d: <%s+%#x>[%#x] -> %s\n", i, info.dli_sname,
+			(uintptr_t)buffer[i] - (uintptr_t)info.dli_saddr,
+			(uintptr_t)buffer[i] - (uintptr_t)info.dli_fbase, info.dli_fname);
+		str_location[i] = str_buffer;
+		total_size += strlen(str_buffer) + 1;
+	}
+	string = (char **)malloc(total_size + (size * sizeof(char *)));
+	if (string == NULL) {
+		goto err;
+	}
+	memset(string, 0, total_size + (size * sizeof(char *)));
+	str_base = (char *)(string + size);
+	for (i = 0; i < size; ++i) {
+		if (str_location[i] == NULL) {
+			break;
+		}
+		strcpy(str_base, str_location[i]);
+		string[i] = str_base;
+		str_base += strlen(string[i]) + 1;
+		free(str_location[i]);
+	}
+	free(str_location);
+	return string;
+
+err:
+	for (i = 0; i < size; ++i) {
+		if (str_location[i]) {
+			free(str_location[i]);
+		}
+	}
+	free(str_location);
+	return NULL;
+}
+
+static void get_backtrace_addr(void *const *buffer, int nptrs)
+{
+	for (int i = 1; i < nptrs; ++i) {
+		printf("    #%02d: %#x\n", i, buffer[i]);
+	}
+}
+
+void print_trace()
+{
+	int nptrs, i;
+	void *buffer[TRACE_MAX_DEPTH];
+	char **strings = NULL;
+
+	nptrs = backtrace(buffer, TRACE_MAX_DEPTH);
+	printf("\nBacktrace() returned %d addresses\n", nptrs - TRACE_IGNORE);
+	strings = backtrace_symbols(buffer, nptrs);
+	if (strings == NULL) {
+		printf("backtrace_symbols() err!\n");
+		return;
+	}
+	for (i = 1; i < nptrs; ++i) {
+		if ((i == 1) && (strings[i] == NULL)) {
+			get_backtrace_addr(buffer, nptrs);
+			break;
+		}
+		printf("%s", strings[i]);
+	}
+	free(strings);
+}
+
diff --git a/src/malloc/malloc.c b/src/malloc/malloc.c
old mode 100644
new mode 100755
index df00631f..ba6900a4
--- a/src/malloc/malloc.c
+++ b/src/malloc/malloc.c
@@ -4,6 +4,8 @@
 #include <limits.h>
 #include <stdint.h>
 #include <errno.h>
+#include <unistd.h>
+#include <debug.h>
 #include <sys/mman.h>
 #include "libc.h"
 #include "atomic.h"
@@ -143,6 +145,7 @@ static struct chunk *expand_heap(size_t n)
 		return 0;
 	}
 
+	lock(g_mem_lock);
 	/* If not just expanding existing space, we need to make a
 	 * new sentinel chunk below the allocated space. */
 	if (p != end) {
@@ -151,6 +154,7 @@ static struct chunk *expand_heap(size_t n)
 		p = (char *)p + SIZE_ALIGN;
 		w = MEM_TO_CHUNK(p);
 		w->psize = 0 | C_INUSE;
+		insert_block_list(w);
 	}
 
 	/* Record new heap end and fill in footer. */
@@ -163,7 +167,9 @@ static struct chunk *expand_heap(size_t n)
 	 * zero-size sentinel header at the old end-of-heap. */
 	w = MEM_TO_CHUNK(p);
 	w->csize = n | C_INUSE;
+	calculate_checksum(w, MEM_TO_CHUNK(end));
 
+	unlock(g_mem_lock);
 	unlock(heap_lock);
 
 	return w;
@@ -251,7 +257,7 @@ static int pretrim(struct chunk *self, size_t n, int i, int j)
 
 	next = NEXT_CHUNK(self);
 	split = (void *)((char *)self + n);
-
+	lock(g_mem_lock);
 	split->prev = self->prev;
 	split->next = self->next;
 	split->prev->next = split;
@@ -259,7 +265,10 @@ static int pretrim(struct chunk *self, size_t n, int i, int j)
 	split->psize = n | C_INUSE;
 	split->csize = n1-n;
 	next->psize = n1-n;
+	calculate_checksum(split, next);
 	self->csize = n | C_INUSE;
+	calculate_checksum(self, NULL);
+	unlock(g_mem_lock);
 	return 1;
 }
 
@@ -272,11 +281,14 @@ static void trim(struct chunk *self, size_t n)
 
 	next = NEXT_CHUNK(self);
 	split = (void *)((char *)self + n);
-
+	lock(g_mem_lock);
 	split->psize = n | C_INUSE;
 	split->csize = n1-n | C_INUSE;
 	next->psize = n1-n | C_INUSE;
+	calculate_checksum(split, next);
 	self->csize = n | C_INUSE;
+	calculate_checksum(self, NULL);
+	unlock(g_mem_lock);
 
 	__bin_chunk(split);
 }
@@ -290,12 +302,27 @@ void *malloc(size_t n)
 
 	if (n > MMAP_THRESHOLD) {
 		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
+		if (g_enable_check) {
+			/* Allocate two more pages for protection, loacted at the head and tail of user memory respectively */
+			len += PAGE_SIZE << 1;
+		}
 		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
 			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
 		if (base == (void *)-1) return 0;
+		if (g_enable_check) {
+			if (mprotect(base, PAGE_SIZE, PROT_NONE) ||
+				mprotect(base + len - PAGE_SIZE, PAGE_SIZE, PROT_NONE)) {
+				printf("%s %d, mprotect failed, err: %s!\n", __func__, __LINE__, strerror(errno));
+			}
+			base += PAGE_SIZE;
+		}
 		c = (void *)(base + SIZE_ALIGN - OVERHEAD);
 		c->csize = len - (SIZE_ALIGN - OVERHEAD);
 		c->psize = SIZE_ALIGN - OVERHEAD;
+		if (g_enable_check) {
+			c->csize -= PAGE_SIZE << 1;
+			insert_node(CHUNK_TO_MEM(c), CHUNK_SIZE(c));
+		}
 		return CHUNK_TO_MEM(c);
 	}
 
@@ -306,10 +333,13 @@ void *malloc(size_t n)
 			c = expand_heap(n);
 			if (!c) return 0;
 			if (alloc_rev(c)) {
+				lock(g_mem_lock);
 				struct chunk *x = c;
 				c = PREV_CHUNK(c);
 				NEXT_CHUNK(x)->psize = c->csize =
 					x->csize + CHUNK_SIZE(c);
+				calculate_checksum(c, NEXT_CHUNK(x));
+				unlock(g_mem_lock);
 			}
 			break;
 		}
@@ -326,6 +356,9 @@ void *malloc(size_t n)
 
 	/* Now patch up in case we over-allocated */
 	trim(c, n);
+	if (g_enable_check) {
+		insert_node(CHUNK_TO_MEM(c), CHUNK_SIZE(c));
+	}
 
 	return CHUNK_TO_MEM(c);
 }
@@ -385,13 +418,23 @@ void *realloc(void *p, size_t n)
 		size_t oldlen = n0 + extra;
 		size_t newlen = n + extra;
 		/* Crash on realloc of freed chunk */
-		if (extra & 1) a_crash();
+		if (extra & 1) {
+			if (g_enable_check) {
+				get_free_trace(CHUNK_TO_MEM(self));
+				a_crash();
+			} else {
+				a_crash();
+			}
+		}
 		if (newlen < PAGE_SIZE && (new = malloc(n-OVERHEAD))) {
 			n0 = n;
 			goto copy_free_ret;
 		}
 		newlen = (newlen + PAGE_SIZE-1) & -PAGE_SIZE;
 		if (oldlen == newlen) return p;
+		if (g_enable_check) {
+			goto copy_realloc;
+		}
 		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
 		if (base == (void *)-1)
 			goto copy_realloc;
@@ -417,13 +460,25 @@ void *realloc(void *p, size_t n)
 		self = PREV_CHUNK(self);
 		n1 += CHUNK_SIZE(self);
 	}
+	lock(g_mem_lock);
 	self->csize = n1 | C_INUSE;
 	next->psize = n1 | C_INUSE;
+	calculate_checksum(self, next);
+	unlock(g_mem_lock);
 
 	/* If we got enough space, split off the excess and return */
 	if (n <= n1) {
 		//memmove(CHUNK_TO_MEM(self), p, n0-OVERHEAD);
 		trim(self, n);
+		if (g_enable_check) {
+			int status = delete_node(p);
+			if (status != 0) {
+				get_free_trace(CHUNK_TO_MEM(self));
+				a_crash();
+			}
+			insert_node(CHUNK_TO_MEM(self), CHUNK_SIZE(self));
+		}
+
 		return CHUNK_TO_MEM(self);
 	}
 
@@ -431,6 +486,7 @@ copy_realloc:
 	/* As a last resort, allocate a new chunk and copy to it. */
 	new = malloc(n-OVERHEAD);
 	if (!new) return 0;
+	n0 = (n0 > n) ? n : n0;
 copy_free_ret:
 	memcpy(new, p, n0-OVERHEAD);
 	free(CHUNK_TO_MEM(self));
@@ -451,8 +507,11 @@ void __bin_chunk(struct chunk *self)
 
 	for (;;) {
 		if (self->psize & next->csize & C_INUSE) {
+			lock(g_mem_lock);
 			self->csize = final_size | C_INUSE;
 			next->psize = final_size | C_INUSE;
+			calculate_checksum(self, next);
+			unlock(g_mem_lock);
 			i = bin_index(final_size);
 			lock_bin(i);
 			lock(mal.free_lock);
@@ -482,8 +541,11 @@ void __bin_chunk(struct chunk *self)
 	if (!(mal.binmap & 1ULL<<i))
 		a_or_64(&mal.binmap, 1ULL<<i);
 
+	lock(g_mem_lock);
 	self->csize = final_size;
 	next->psize = final_size;
+	calculate_checksum(self, next);
+	unlock(g_mem_lock);
 	unlock(mal.free_lock);
 
 	self->next = BIN_TO_CHUNK(i);
@@ -512,7 +574,18 @@ static void unmap_chunk(struct chunk *self)
 	char *base = (char *)self - extra;
 	size_t len = CHUNK_SIZE(self) + extra;
 	/* Crash on double free */
-	if (extra & 1) a_crash();
+	if (extra & 1) {
+		if (g_enable_check) {
+			get_free_trace(CHUNK_TO_MEM(self));
+			a_crash();
+		} else {
+			a_crash();
+		}
+	}
+	if (g_enable_check) {
+		base -= PAGE_SIZE;
+		len += PAGE_SIZE << 1;
+	}
 	__munmap(base, len);
 }
 
@@ -521,28 +594,54 @@ void free(void *p)
 	if (!p) return;
 
 	struct chunk *self = MEM_TO_CHUNK(p);
+	if (g_enable_check) {
+		if (!IS_MMAPPED(self)) {
+			check_chunk_integrity(self);
+		}
+		int status = delete_node(p);
+		if (status != 0) {
+			get_free_trace(p);
+			a_crash();
+		}
+	}
 
 	if (IS_MMAPPED(self))
 		unmap_chunk(self);
-	else
+	else {
+		if (g_enable_check) {
+			insert_free_tail(self);
+			if (g_recycle_size >= RECYCLE_SIZE_MAX) {
+				clean_recycle_list(false);
+				return;
+			}
+			if (g_recycle_num < RECYCLE_MAX) {
+				return;
+			}
+			self = get_free_head();
+		}
 		__bin_chunk(self);
+	}
 }
 
 void __malloc_donate(char *start, char *end)
 {
-	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - OVERHEAD);
+	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - BLOCK_HEAD);
 	size_t align_end_down = (SIZE_ALIGN-1) & (uintptr_t)end;
 
 	/* Getting past this condition ensures that the padding for alignment
 	 * and header overhead will not overflow and will leave a nonzero
 	 * multiple of SIZE_ALIGN bytes between start and end. */
-	if (end - start <= OVERHEAD + align_start_up + align_end_down)
+	if (end - start <= BLOCK_HEAD + align_start_up + align_end_down)
 		return;
-	start += align_start_up + OVERHEAD;
+	start += align_start_up + BLOCK_HEAD;
 	end   -= align_end_down;
 
+	lock(g_mem_lock);
 	struct chunk *c = MEM_TO_CHUNK(start), *n = MEM_TO_CHUNK(end);
 	c->psize = n->csize = C_INUSE;
 	c->csize = n->psize = C_INUSE | (end-start);
+	calculate_checksum(c, n);
+	insert_block_list(c);
+	unlock(g_mem_lock);
 	__bin_chunk(c);
 }
diff --git a/src/malloc/memalign.c b/src/malloc/memalign.c
index cf9dfbda..a37c5444 100644
--- a/src/malloc/memalign.c
+++ b/src/malloc/memalign.c
@@ -1,8 +1,24 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <errno.h>
+#include "libc.h"
+#include "pthread_impl.h"
 #include "malloc_impl.h"
 
+static inline void lock(volatile int *lk)
+{
+	if (libc.threads_minus_1)
+		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+}
+
+static inline void unlock(volatile int *lk)
+{
+	if (lk[0]) {
+		a_store(lk, 0);
+		if (lk[1]) __wake(lk, 1, 1);
+	}
+}
+
 void *__memalign(size_t align, size_t len)
 {
 	unsigned char *mem, *new;
@@ -29,11 +45,22 @@ void *__memalign(size_t align, size_t len)
 	struct chunk *c = MEM_TO_CHUNK(mem);
 	struct chunk *n = MEM_TO_CHUNK(new);
 
+	if (g_enable_check) {
+		int status = delete_node(mem);
+		if (status != 0) {
+			get_free_trace(mem);
+			a_crash();
+		}
+	}
+
 	if (IS_MMAPPED(c)) {
 		/* Apply difference between aligned and original
 		 * address to the "extra" field of mmapped chunk. */
 		n->psize = c->psize + (new-mem);
 		n->csize = c->csize - (new-mem);
+		if (g_enable_check) {
+			insert_node(CHUNK_TO_MEM(n), CHUNK_SIZE(n));
+		}
 		return new;
 	}
 
@@ -44,8 +71,15 @@ void *__memalign(size_t align, size_t len)
 	 * difference between the aligned and original addresses, and
 	 * the resulting size copied to its header. A new header and
 	 * footer are written for the split-off part to be freed. */
+	lock(g_mem_lock);
 	n->psize = c->csize = C_INUSE | (new-mem);
 	n->csize = t->psize -= new-mem;
+	calculate_checksum(c, n);
+	calculate_checksum(NULL, t);
+	unlock(g_mem_lock);
+	if (g_enable_check) {
+		insert_node(CHUNK_TO_MEM(n), CHUNK_SIZE(n));
+	}
 
 	__bin_chunk(c);
 	return new;
diff --git a/src/malloc/memory_check.c b/src/malloc/memory_check.c
new file mode 100644
index 00000000..6ef7e750
--- /dev/null
+++ b/src/malloc/memory_check.c
@@ -0,0 +1,831 @@
+#define _GNU_SOURCE
+#include <errno.h>
+#include <string.h>
+#include <stdbool.h>
+#include <debug.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include "libc.h"
+#include "atomic.h"
+#include "pthread_impl.h"
+#include "malloc_impl.h"
+
+#if defined(__GNUC__) && defined(__PIC__)
+#define inline inline __attribute__((always_inline))
+#endif
+
+bool g_enable_check = false;
+int g_recycle_num;
+size_t g_recycle_size;
+int g_mem_lock[2];
+static struct chunk recycle_list;
+static struct heap_block block_list;
+
+static struct {
+	struct stat_bin bins[PTHREAD_NUM_MAX];
+	struct stat_bin free_list;
+	size_t p_total_size;
+	size_t peak_size;
+	char *f_path;
+	char f_path_buf[PATH_MAX];
+	int fd;
+	bool verbose;
+} mem_stat;
+
+static inline void lock(volatile int *lk)
+{
+	if (libc.threads_minus_1)
+		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
+}
+
+static inline void unlock(volatile int *lk)
+{
+	if (lk[0]) {
+		a_store(lk, 0);
+		if (lk[1]) __wake(lk, 1, 1);
+	}
+}
+
+static inline void lock_stat_bin(int tid)
+{
+	lock(mem_stat.bins[tid].lock);
+	if (!mem_stat.bins[tid].head.next)
+		mem_stat.bins[tid].head.next = mem_stat.bins[tid].head.prev = &mem_stat.bins[tid].head;
+}
+
+static inline void unlock_stat_bin(int tid)
+{
+	unlock(mem_stat.bins[tid].lock);
+}
+
+static void insert_free_list(struct node *node)
+{
+	struct list *list = NULL;
+
+	list = mem_stat.free_list.head.prev;
+	node->list.prev = list;
+	node->list.next = list->next;
+	list->next = &node->list;
+	node->list.next->prev = &node->list;
+}
+
+static int try_delete_node(int tid, void *ptr)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+
+	lock_stat_bin(tid);
+	for (list = mem_stat.bins[tid].head.next; list != &mem_stat.bins[tid].head; list = list->next) {
+		node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+		if (node->ptr != ptr) {
+			continue;
+		}
+		list->prev->next = list->next;
+		list->next->prev = list->prev;
+		mem_stat.bins[tid].t_total_size -= node->size;
+		insert_free_list(node);
+		mem_stat.p_total_size -= node->size;
+		unlock_stat_bin(tid);
+		return 0;
+	}
+	unlock_stat_bin(tid);
+	return -1;
+}
+
+int delete_node(void *ptr)
+{
+	int tid = ((struct pthread *)pthread_self())->tid;
+	int status, i;
+
+	lock(g_mem_lock);
+	status = try_delete_node(tid, ptr);
+	if (status == 0) {
+		unlock(g_mem_lock);
+		return 0;
+	}
+
+	for (i = 0; i < PTHREAD_NUM_MAX; ++i) {
+		if (i == tid) {
+			continue;
+		}
+		status = try_delete_node(i, ptr);
+		if (status == 0) {
+			unlock(g_mem_lock);
+			return 0;
+		}
+	}
+	unlock(g_mem_lock);
+	return -1;
+}
+
+static struct node *expand_mem(void)
+{
+	struct node *ptr = NULL;
+	struct node *node = NULL;
+	size_t node_len = sizeof(struct node);
+	int n_node = PAGE_SIZE / node_len;
+	int i;
+
+	ptr = __mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	if (ptr == MAP_FAILED) {
+		printf("%s %d, map failed, err: %s\n", __func__, __LINE__, strerror(errno));
+		return NULL;
+	}
+
+	for (i = 1; i < n_node; ++i) {
+		node = (struct node *)((uintptr_t)ptr + i * node_len);
+		insert_free_list(node);
+	}
+
+	return ptr;
+}
+
+static struct node *alloc_node(void)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+	int ret;
+
+	if (!mem_stat.free_list.head.next) {
+		mem_stat.free_list.head.next = mem_stat.free_list.head.prev = &mem_stat.free_list.head;
+	}
+
+	for (list = mem_stat.free_list.head.next; list != &mem_stat.free_list.head; list = list->next) {
+		node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+		list->prev->next = list->next;
+		list->next->prev = list->prev;
+		return node;
+	}
+
+	return expand_mem();
+}
+
+static struct node *create_node(int tid, void *ptr, size_t size)
+{
+	pid_t pid = getpid();
+	struct node *node = NULL;
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET + 1] = { 0 };
+	int nptr;
+
+	node = alloc_node();
+	if (node == NULL) {
+		return NULL;
+	}
+	mem_stat.p_total_size += size;
+	mem_stat.peak_size = (mem_stat.peak_size < mem_stat.p_total_size) ? mem_stat.p_total_size : mem_stat.peak_size;
+	node->tid = tid;
+	node->pid = pid;
+	node->ptr = ptr;
+	node->size = size;
+	nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET + 1);
+	memcpy(node->lr, lr + BACKTRACE_OFFSET + 1, BACKTRACE_DEPTH_MAX * sizeof(void *));
+	return node;
+}
+
+void insert_node(void *ptr, size_t size)
+{
+	int tid = ((struct pthread *)pthread_self())->tid;
+	struct list *list = NULL;
+	struct node *node = NULL;
+
+	lock(g_mem_lock);
+	node = create_node(tid, ptr, size);
+	if (node == NULL) {
+		unlock(g_mem_lock);
+		return;
+	}
+
+	lock_stat_bin(tid);
+	mem_stat.bins[tid].t_total_size += size;
+	list = mem_stat.bins[tid].head.prev;
+	node->list.prev = list;
+	node->list.next = list->next;
+	list->next = &node->list;
+	node->list.next->prev = &node->list;
+	unlock_stat_bin(tid);
+	unlock(g_mem_lock);
+}
+
+static void file_path_init(void)
+{
+	char *pos = NULL;
+	int len;
+
+	if (!mem_stat.f_path) {
+		return;
+	}
+
+	pos = strrchr(mem_stat.f_path, '/');
+	if (pos) {
+		len = pos - mem_stat.f_path + 1;
+		strncpy(mem_stat.f_path_buf, mem_stat.f_path, PATH_MAX - 1);
+		snprintf(mem_stat.f_path_buf + len, PATH_MAX - len, "pid(%d)_%s", getpid(), pos + 1);
+	} else {
+		snprintf(mem_stat.f_path_buf, PATH_MAX, "pid(%d)_%s", getpid(), mem_stat.f_path);
+	}
+}
+
+static bool get_file(void)
+{
+	if (!g_enable_check) {
+		printf("You should call mem_check_init(char *) or use command line parameters, "
+			"--mwatch or --mrecord <full path>, to call mem_check_init(char *) "
+			"when executing your program.\n");
+		return false;
+	}
+
+	if (mem_stat.verbose) {
+		return true;
+	}
+
+	file_path_init();
+	if (!access(mem_stat.f_path_buf, 0)) {
+		return true;
+	}
+	mem_stat.fd = open(mem_stat.f_path_buf, O_RDWR | O_CREAT);
+	if (mem_stat.fd < 0) {
+		printf("err: %s create failed, memory info will output from serial port!\n", mem_stat.f_path_buf);
+		mem_stat.verbose = true;
+	}
+	return true;
+}
+
+static int get_backtrace_info(void **buffer, int nptr, int fd, bool verbose, bool checkpoint)
+{
+	int i, ret;
+	char str_buf[ITEM_BUFFER_SIZE];
+	Dl_info info = { 0 };
+	bool checkpoint_head = false;
+	int checkpoint_trace_num = 0;
+	bool symbol_found;
+
+	for (i = 0; i < nptr; ++i) {
+		symbol_found = true;
+		dladdr((void *)buffer[i], &info);
+		if ((info.dli_fname == NULL) || (info.dli_fname[0] == '\0')) {
+			symbol_found = false;
+		}
+
+		if (checkpoint && !checkpoint_head) {
+			checkpoint_head = true;
+			if (verbose) {
+				printf("    [Check point]:\n");
+			} else {
+				snprintf(str_buf, ITEM_BUFFER_SIZE, "    [Check point]:\n");
+				ret = write(fd, str_buf, strlen(str_buf));
+				if (ret != strlen(str_buf)) {
+					goto err;
+				}
+			}
+		}
+		if (verbose) {
+			symbol_found ?
+			printf("\t#%02d: <%s+%#x>[%#x] -> %s\n", i, info.dli_sname, (uintptr_t)buffer[i] -
+				(uintptr_t)info.dli_saddr, (uintptr_t)buffer[i] - (uintptr_t)info.dli_fbase, info.dli_fname) :
+			printf("\t#%02d: %#x\n", i, buffer[i]);
+		} else {
+			symbol_found ?
+			snprintf(str_buf, ITEM_BUFFER_SIZE, "\t#%02d: <%s+%#x>[%#x] -> %s\n", i, info.dli_sname,
+				(uintptr_t)buffer[i] - (uintptr_t)info.dli_saddr, (uintptr_t)buffer[i] - (uintptr_t)info.dli_fbase,
+				info.dli_fname) :
+			snprintf(str_buf, ITEM_BUFFER_SIZE, "\t#%02d: %#x\n", i, buffer[i]);
+			ret = write(fd, str_buf, strlen(str_buf));
+			if (ret != strlen(str_buf)) {
+				goto err;
+			}
+		}
+		if (checkpoint) {
+			checkpoint_trace_num++;
+			if (checkpoint_trace_num == CHECK_POINT_TRACE_MAX) {
+				break;
+			}
+		}
+	}
+	return 0;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	return ret;
+}
+
+static int print_integrity_info(struct node *node)
+{
+	int ret;
+	char buffer[ITEM_BUFFER_SIZE];
+	char *str = "The possible attacker was allocated from:";
+
+	if (mem_stat.verbose) {
+		printf("\n==PID:%d== Memory integrity information:\n", getpid());
+		printf("    [TID:%d PID:%d allocated addr: %#x, size: %#x] %s\n", node->tid, node->pid, node->ptr, node->size,
+			str);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== Memory integrity information:\n", getpid());
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+		snprintf(buffer, ITEM_BUFFER_SIZE, "    [TID:%d PID:%d allocated addr: %#x, size: %#x] %s\n", node->tid, node->pid,
+			node->ptr, node->size, str);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+	}
+	return 0;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	return ret;
+}
+
+static int check_mem_integrity(int tid, void *ptr)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+	int nptr = 0;
+
+	lock_stat_bin(tid);
+	for (list = mem_stat.bins[tid].head.next; list != &mem_stat.bins[tid].head; list = list->next) {
+		node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+		if (node->ptr != ptr) {
+			continue;
+		}
+		if (print_integrity_info(node) != 0) {
+			unlock_stat_bin(tid);
+			printf("Memory integrity check failed!\n");
+			return -1;
+		}
+		while (node->lr[nptr] != NULL) {
+			++nptr;
+			if (nptr == BACKTRACE_DEPTH_MAX) {
+				break;
+			}
+		}
+		if ((nptr == 0) || (get_backtrace_info(node->lr, nptr, mem_stat.fd, mem_stat.verbose, false) != 0)) {
+			unlock_stat_bin(tid);
+			printf("get backtrace failed!\n");
+			return -1;
+		}
+		if (!mem_stat.verbose) {
+			printf("Memory integrity information saved in %s\n", mem_stat.f_path_buf);
+		}
+		unlock_stat_bin(tid);
+		return 0;
+	}
+	unlock_stat_bin(tid);
+	return 1;
+}
+
+static void get_integrity_info(void *ptr)
+{
+	int i, status;
+	int tid = ((struct pthread *)pthread_self())->tid;
+
+	status = check_mem_integrity(tid, ptr);
+	if (status != 1) {
+		return;
+	}
+
+	for (i = 0; i < PTHREAD_NUM_MAX; ++i) {
+		if (i == tid) {
+			continue;
+		}
+		status = check_mem_integrity(i, ptr);
+		if (status != 1) {
+			return;
+		}
+	}
+}
+
+bool is_invalid(struct chunk *self)
+{
+	uint32_t checksum;
+	checksum = CHUNK_SIZE(self) ^ CHUNK_PSIZE(self) ^ NODE_MAGIC;
+	if (checksum != self->checksum) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+void calculate_checksum(struct chunk *cur, struct chunk *next)
+{
+	if (cur) {
+		cur->checksum = CHUNK_SIZE(cur) ^ CHUNK_PSIZE(cur) ^ NODE_MAGIC;
+	}
+
+	if (next) {
+		next->checksum = CHUNK_SIZE(next) ^ CHUNK_PSIZE(next) ^ NODE_MAGIC;
+	}
+}
+
+void check_heap_integrity(void)
+{
+	struct chunk *cur = NULL;
+	struct chunk *next = NULL;
+	struct heap_block *block = NULL;
+
+	if (!block_list.next) {
+		return;
+	}
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	block = block_list.next;
+	while (block != &block_list) {
+		cur = BLOCK_TO_CHUNK(block);
+		do {
+			next = NEXT_CHUNK(cur);
+			if (is_invalid(next)) {
+				get_integrity_info(CHUNK_TO_MEM(cur));
+				unlock(g_mem_lock);
+				a_crash();
+			}
+			cur = next;
+		} while (CHUNK_SIZE(next));
+		block = block->next;
+	}
+	unlock(g_mem_lock);
+	printf("\nCheck heap integrity ok!\n");
+}
+
+void check_chunk_integrity(struct chunk *cur)
+{
+	struct chunk *next = NULL;
+
+	if (is_invalid(cur)) {
+		check_heap_integrity();
+	}
+
+	lock(g_mem_lock);
+	next = NEXT_CHUNK(cur);
+	if ((CHUNK_SIZE(next)) && is_invalid(next)) {
+		get_integrity_info(CHUNK_TO_MEM(cur));
+		unlock(g_mem_lock);
+		a_crash();
+	}
+	unlock(g_mem_lock);
+}
+
+void insert_block_list(struct chunk *self)
+{
+	struct heap_block *block = CHUNK_TO_BLOCK(self);
+	struct heap_block *cur = NULL;
+
+	if (!block_list.next) {
+		block_list.next = block_list.prev = &block_list;
+	}
+
+	cur = block_list.prev;
+	block->next = cur->next;
+	block->prev = cur;
+	cur->next = block;
+	block_list.prev = block;
+}
+
+void get_free_trace(void *ptr)
+{
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET] = { 0 };
+	int tid = ((struct pthread *)pthread_self())->tid;
+	char buffer[ITEM_BUFFER_SIZE];
+	int nptr, ret;
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	if (mem_stat.verbose) {
+		printf("\n==PID:%d== double free\n", getpid());
+		printf("    [TID:%d freed addr: %#x]:\n", tid, ptr);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== double free\n", getpid());
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+		snprintf(buffer, ITEM_BUFFER_SIZE, "    [TID:%d freed addr: %#x]:\n", tid, ptr);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+	}
+
+	nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET);
+	if (get_backtrace_info(lr + BACKTRACE_OFFSET, nptr - BACKTRACE_OFFSET, mem_stat.fd, mem_stat.verbose, false) != 0) {
+		printf("Trace failed\n");
+	}
+
+	unlock(g_mem_lock);
+	return;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	unlock(g_mem_lock);
+	return;
+}
+
+void watch_mem(void)
+{
+	int tid, ret;
+	char buffer[ITEM_BUFFER_SIZE];
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET] = { 0 };
+	pid_t pid = getpid();
+	int nptr;
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	if (mem_stat.verbose) {
+		printf("\n==PID:%d== Heap memory statistics(bytes):\n", pid);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== Heap memory statistics(bytes):\n", pid);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err2;
+		}
+	}
+	nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET);
+	if (get_backtrace_info(lr + BACKTRACE_OFFSET, nptr - BACKTRACE_OFFSET, mem_stat.fd, mem_stat.verbose, true) != 0) {
+		printf("Check failed\n");
+		unlock(g_mem_lock);
+		return;
+	}
+	for (tid = 0; tid < PTHREAD_NUM_MAX; ++tid) {
+		lock_stat_bin(tid);
+		if (mem_stat.bins[tid].t_total_size == 0) {
+			unlock_stat_bin(tid);
+			continue;
+		}
+		if (mem_stat.verbose) {
+			printf("\n    [TID: %d, Used: %#x]", tid, mem_stat.bins[tid].t_total_size);
+		} else {
+			snprintf(buffer, ITEM_BUFFER_SIZE, "\n    [TID: %d, Used: %#x]", tid, mem_stat.bins[tid].t_total_size);
+			ret = write(mem_stat.fd, buffer, strlen(buffer));
+			if (ret != strlen(buffer)) {
+				goto err1;
+			}
+		}
+		unlock_stat_bin(tid);
+	}
+	if (mem_stat.verbose) {
+		printf("\n\n==PID:%d== Total heap: %#x byte(s), Peak: %#x byte(s)\n", pid,
+				mem_stat.p_total_size, mem_stat.peak_size);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n\n==PID:%d== Total heap: %#x byte(s), Peak: %#x byte(s)\n", pid,
+				 mem_stat.p_total_size, mem_stat.peak_size);
+		ret = write(mem_stat.fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err2;
+		}
+	}
+	if (!mem_stat.verbose) {
+		printf("Memory statistics information saved in %s\n", mem_stat.f_path_buf);
+	}
+	unlock(g_mem_lock);
+	return;
+err1:
+	unlock_stat_bin(tid);
+err2:
+	printf("Write failed, err: %s\n", strerror(errno));
+	unlock(g_mem_lock);
+}
+
+static int get_node_info(struct node *node, int fd, bool verbose, bool mem_leak_exist)
+{
+	char buffer[ITEM_BUFFER_SIZE];
+	void *lr[BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET] = { 0 };
+	int nptr, ret;
+
+	if (!mem_leak_exist) {
+		if (verbose) {
+			printf("\n==PID:%d== Detected memory leak(s):\n", getpid());
+		} else {
+			snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== Detected memory leak(s):\n", getpid());
+			ret = write(fd, buffer, strlen(buffer));
+			if (ret != strlen(buffer)) {
+				goto err;
+			}
+		}
+		nptr = backtrace(lr, BACKTRACE_DEPTH_MAX + BACKTRACE_OFFSET);
+		if (get_backtrace_info(lr + BACKTRACE_OFFSET, nptr - BACKTRACE_OFFSET, mem_stat.fd, mem_stat.verbose, true) != 0) {
+			printf("Check failed\n");
+			goto err;
+		}
+	}
+
+	if (verbose) {
+		printf("\n    [TID:%d Leak:%#x byte(s)] Allocated from:\n", node->tid, node->size);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n    [TID:%d Leak:%#x byte(s)] Allocated from:\n", node->tid, node->size);
+		ret = write(fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			goto err;
+		}
+	}
+	return 0;
+err:
+	printf("Write failed, err: %s\n", strerror(errno));
+	return ret;
+
+}
+
+static void print_summary_info(size_t leak_size, size_t allocs, int fd, bool verbose, bool mem_leak_exist)
+{
+	char buffer[ITEM_BUFFER_SIZE];
+	int ret;
+
+	if (!mem_leak_exist) {
+		if (verbose) {
+			printf("\nNo memory leak!\n");
+			return;
+		} else {
+			snprintf(buffer, ITEM_BUFFER_SIZE, "\nNo memory leak!\n");
+			ret = write(fd, buffer, strlen(buffer));
+			if (ret != strlen(buffer)) {
+				printf("Write failed, err: %s\n", strerror(errno));
+			}
+			return;
+		}
+	}
+
+	if (verbose) {
+		printf("\n==PID:%d== SUMMARY: %#x byte(s) leaked in %d allocation(s).\n", getpid(), leak_size, allocs);
+	} else {
+		snprintf(buffer, ITEM_BUFFER_SIZE, "\n==PID:%d== SUMMARY: %#x byte(s) leaked in %d allocation(s).\n", getpid(),
+			leak_size, allocs);
+		ret = write(fd, buffer, strlen(buffer));
+		if (ret != strlen(buffer)) {
+			printf("Write failed, err: %s\n", strerror(errno));
+		}
+	}
+}
+
+void check_leak(void)
+{
+	struct list *list = NULL;
+	struct node *node = NULL;
+	int tid, nptr;
+	size_t leak_size = 0;
+	size_t allocs = 0;
+	bool mem_leak_exist = false;
+	pid_t pid = getpid();
+
+	lock(g_mem_lock);
+	if (!get_file()) {
+		unlock(g_mem_lock);
+		return;
+	}
+	for (tid = 0; tid < PTHREAD_NUM_MAX; ++tid) {
+		lock_stat_bin(tid);
+		for (list = mem_stat.bins[tid].head.next; list != &mem_stat.bins[tid].head; list = list->next) {
+			node = (struct node *)((uintptr_t)list - (uint32_t)&((struct node *)0)->list);
+			if (node->pid != pid) {
+				continue;
+			}
+			if (get_node_info(node, mem_stat.fd, mem_stat.verbose, mem_leak_exist) != 0) {
+				unlock_stat_bin(tid);
+				unlock(g_mem_lock);
+				printf("Check failed\n");
+				return;
+			}
+			++allocs;
+			leak_size += node->size;
+			mem_leak_exist = true;
+			nptr = 0;
+			while (node->lr[nptr] != NULL) {
+				++nptr;
+				if (nptr == BACKTRACE_DEPTH_MAX) {
+					break;
+				}
+			}
+			if (nptr == 0) {
+				continue;
+			}
+			if (get_backtrace_info(node->lr, nptr, mem_stat.fd, mem_stat.verbose, false) != 0) {
+				unlock_stat_bin(tid);
+				unlock(g_mem_lock);
+				printf("Check failed\n");
+				return;
+			}
+		}
+		unlock_stat_bin(tid);
+	}
+	print_summary_info(leak_size, allocs, mem_stat.fd, mem_stat.verbose, mem_leak_exist);
+	if (!mem_stat.verbose) {
+		printf("Leak check information saved in %s\n", mem_stat.f_path_buf);
+	}
+	unlock(g_mem_lock);
+}
+
+void mem_check_init(char *f_path)
+{
+	signal(35, watch_mem);
+	signal(36, check_leak);
+	signal(37, check_heap_integrity);
+	g_enable_check = true;
+	mem_stat.fd = -1;
+	const char *string = "memory info will print to serial port!";
+
+	if (!f_path) {
+		goto out;
+	}
+
+	if (strlen(f_path) > (PATH_MAX - PREFIX_PLACE_HOLDER - 1)) {
+		printf("file name: %s is too long, %s\n", f_path, string);
+		goto out;
+	}
+	mem_stat.f_path = f_path;
+	file_path_init();
+	mem_stat.fd = open(mem_stat.f_path_buf, O_RDWR | O_CREAT | O_EXCL);
+	if (mem_stat.fd < 0) {
+		switch (errno) {
+		case EEXIST:
+			printf("file: %s is exist, %s\n", mem_stat.f_path_buf, string);
+			goto out;
+		default:
+			printf("path: %s create failed, %s\n", mem_stat.f_path_buf, string);
+			goto out;
+		}
+	}
+	mem_stat.verbose = false;
+	return;
+
+out:
+	mem_stat.verbose = true;
+}
+
+void mem_check_deinit()
+{
+	if (mem_stat.fd > 0) {
+		close(mem_stat.fd);
+	}
+}
+
+void parse_argv(int argc, char *argv[])
+{
+
+	if (argc <= 1) {
+		return;
+	}
+
+	if (!strcmp(argv[argc - 1], "--mwatch")) {
+		mem_check_init(NULL);
+	} else if ((argc > 2) && (!strcmp(argv[argc - 2], "--mrecord"))) {
+		mem_check_init(argv[argc - 1]);
+	} else if (!strcmp(argv[argc - 1], "--mrecord")) {
+		printf("usage: --mrecord filepath\n");
+	}
+}
+
+void insert_free_tail(struct chunk *self)
+{
+	volatile struct chunk *cur = NULL;
+	lock(g_mem_lock);
+	if (!recycle_list.next) {
+		recycle_list.next = recycle_list.prev = &recycle_list;
+	}
+	cur = recycle_list.prev;
+	self->next = cur->next;
+	self->prev = cur;
+	cur->next = self;
+	recycle_list.prev = self;
+	memset(CHUNK_TO_MEM(self), FREE_MAGIC, CHUNK_SIZE(self) - OVERHEAD);
+	++g_recycle_num;
+	g_recycle_size += CHUNK_SIZE(self);
+	unlock(g_mem_lock);
+}
+
+struct chunk *get_free_head(void)
+{
+	struct chunk *cur = NULL;
+	lock(g_mem_lock);
+	cur = recycle_list.next;
+	if ((cur == NULL) || (cur == &recycle_list)) {
+		unlock(g_mem_lock);
+		return NULL;
+	}
+	recycle_list.next = cur->next;
+	cur->next->prev = cur->prev;
+	--g_recycle_num;
+	g_recycle_size -= CHUNK_SIZE(cur);
+	unlock(g_mem_lock);
+	return cur;
+}
+
+void clean_recycle_list(bool clean_all)
+{
+	struct chunk *self = NULL;
+	self = get_free_head();
+	while (self) {
+		__bin_chunk(self);
+		if ((!clean_all) && (g_recycle_size < RECYCLE_SIZE_MAX)) {
+			break;
+		}
+		self = get_free_head();
+	}
+}
+
